import numpy as np
import matplotlib.pyplot as plt

def MWC(x):
    a = 3947008974
    x = a*(x & (2**32 - 1)) + (x >> 32)
    return x
    
def XOR_shift(x):
    a1, a2, a3 = np.uint64(21), np.uint64(35), np.uint64(4)
    x = np.uint64(x)
    x = x ^ (x >> a1)
    x = x ^ (x << a2)
    x = x ^ (x >> a3)
    return x

def RNG(length, norm = True):
    global seed

    randomnumbers = []
    state = seed
   
    for i in range(length):
        state = MWC(state)
        randomnumbers.append(XOR_shift(state))

    randomnumbers = np.array(randomnumbers)

    if norm == True:
        randomnumbers = np.array(randomnumbers)/(2**64)

    #seed = state
    if length == 1:
        return randomnumbers[0]
    else:
        return randomnumbers.tolist()

def gaussian(x, alpha):
    return np.exp(-alpha*(x**2))

def intfunc(x, alpha):
    return np.exp(-alpha*(x**2)) + np.exp(-alpha/(x**2))/(x**2)

def extmidpoint(func, edges, n, **kwargs):
    h = (edges[1]-edges[0])/n
    integration = 0

    for i in range(n):
        integration += func(edges[0]+(i+0.5)*h, **kwargs)
    integration = h*integration

    return integration

def extmidpointromberg(func, edges, n, N, **kwargs):
    s = [[] for i in range(N)]
    s[0].append(extmidpoint(func, edges, n, **kwargs))

    for i in range (1,N):
        n = 2*n
        s[0].append(extmidpoint(func, edges, n, **kwargs))
   
    for j in range(N-1):
        for i in range(N-(j+1)):
            s[j+1].append(s[j][i+1]+(s[j][i+1]-s[j][i])/(-1+4**(j+1)))

    return s[-1][0]

def KS_test(dataset1, dataset2):
    (((dataset1[i]-dataset2[i])**2))**0.5

if __name__ == '__main__':
    seed = 67
    print("The seed has been set to: "+str(seed))

    """
    We create two lists using the RNG method where we compose the lists using our RNG method using only a MWC method composed with a 64-bit XOR_shift.
    We could use a new RNG method that combines different methods in a non-linear fashion. See the book for a better combination method: Ran.
    """

    RNG_list = RNG(1000)
    RNG_list2 = RNG(10**6)

    n_RNG_list = np.array(RNG_list[:-1])
    np1_RNG_list = np.array(RNG_list[1:])

    fig, axs = plt.subplots(1, 2, sharey=False, tight_layout=True)

    axs[0].scatter(n_RNG_list, np1_RNG_list, marker="o", color=(1,0,0), facecolors='none')
    axs[1].hist(RNG_list2, bins = 20, range = (0,1))

    xlabel = ['Combined RNG n', 'Random number generated by combined RNG']
    ylabel = ['Combined RNG n+1', 'Counts']

    i=0
    for ax in axs:
        ax.set(xlabel=xlabel[i], ylabel=ylabel[i])
        i+=1

    fig.savefig('./plots/RNG-test-results')

    """
    For Question 1b) we will integrate the Gaussian integral using the simplification specified in the PDF. We will use Romberg integration since it is very efficient.
    Unclear what method they expect us to use to fit a line through the 21 obtained integrated points. My guess would be something of the form (alpha/x)**0.5 and then using
    least squares or some bayesian fitting method to get the alpha.
    """
    
    integrationpoints = [2*extmidpointromberg(intfunc, [0,1], 10**2, 4, alpha=2**i) for i in range(-10,11)]
    
    fig2, axs2 = plt.subplots()
    axs2.scatter([2**i for i in range(-10,11)], integrationpoints, s=0.1, label='Extended midpoint Romberg', color = (1,0,0))
    axs2.scatter([2**i for i in range(-10,11)], [(np.pi/(2**i))**0.5 for i in range(-10,11)], s=0.1, label='Exact points', color = (0,1,0))
    axs2.set(xlabel='alpha', ylabel='integral')
    axs2.legend()
    fig2.savefig('./plots/gaussianintegral')

    """
    For Question 1c) Box Muller method can be found in 7.3.4 of the book. Does not seem to be anywhere in the slides.
    Are we allowed to use np.cos and np.sin and np.log? Seed and state need to be updated properly, because getting the same RNG number lists gives the wrong results.
    Furthermore the transformations we used below only work for getting a gaussian distribution with mu=0 and sigma=1. We need to figure out how to transform properly
    so we can get any specific form for the gaussian. Also change the graph to what they ask for.
    """

    u1, u2 = np.array(RNG(1000)), np.array(RNG(1000))
    theta = 2*np.pi*u1
    r = (-2*np.log(u2))**0.5
    x = r*np.cos(theta)
    y = r*np.sin(theta)
    
    fig3, axs3 = plt.subplots(1,2, sharey=True)

    axs3[0].hist(u1, bins=100)
    axs3[1].hist(x, bins=100)
    axs3[0].set(xlabel='u1', ylabel='count')
    axs3[1].set(xlabel='x', ylabel='count')

    fig3.savefig('./plots/histogram-gaussian-distribution')

    """
    For Question 1d) look at the details of lecture 8.
    """
    u1d, u2d = np.array(RNG(1000)), np.array(RNG(1000))
    thetad = 2*np.pi*u1
    rd = (-2*np.log(u2))**0.5
    xd = r*np.cos(theta)
    yd = r*np.sin(theta)
    
