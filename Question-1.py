import numpy as np
import matplotlib.pyplot as plt

def MWC(x):
    a = 3947008974
    x = a*(x & (2**32 - 1)) + (x >> 32)
    return x
    
def XOR_shift(x):
   a1, a2, a3 = np.uint64(21), np.uint64(35), np.uint64(4)
   x = np.uint64(x)
   x = x ^ (x >> a1)
   x = x ^ (x << a2)
   x = x ^ (x >> a3)
   return x

def RNG(length, norm = True):
    global seed

    randomnumbers = []
    state = seed
   
    for i in range(length):
        state = MWC(state)
        randomnumbers.append(XOR_shift(state))

    randomnumbers = np.array(randomnumbers)

    if norm == True:
        randomnumbers = np.array(randomnumbers)/(2**64)

    #seed = state
    if length == 1:
        return randomnumbers[0]
    else:
        return randomnumbers.tolist()

def gaussian(x, alpha):
    return np.exp(-alpha*(x**2))

def intfunc(x, alpha):
    return np.exp(-alpha*(x**2)) + np.exp(-alpha/(x**2))/(x**2)

def extmidpoint(func, edges, n, **kwargs):
   h = (edges[1]-edges[0])/n
   integration = 0

   for i in range(n):
       integration += func(edges[0]+(i+0.5)*h, **kwargs)
   integration = h*integration

   return integration

def extmidpointromberg(func, edges, n, N, **kwargs):
   s = [[] for i in range(N)]
   s[0].append(extmidpoint(func, edges, n, **kwargs))

   for i in range (1,N):
      n = 2*n
      s[0].append(extmidpoint(func, edges, n, **kwargs))
   
   for j in range(N-1):
      for i in range(N-(j+1)):
         s[j+1].append(s[j][i+1]+(s[j][i+1]-s[j][i])/(-1+4**(j+1)))

   return s[-1][0]

if __name__ == '__main__':
    seed = 67
    print("The seed has been set to: "+str(seed))

    """
    We create two lists using the RNG method where we compose the lists using our RNG method using only a MWC method composed with a 64-bit XOR_shift.
    We could use a new RNG method that combines different methods in a non-linear fashion. See the book for a better combination method: Ran.
    """

    RNG_list = RNG(1000)
    RNG_list2 = RNG(10**6)

    n_RNG_list = np.array(RNG_list[:-1])
    np1_RNG_list = np.array(RNG_list[1:])

    fig, axs = plt.subplots(1, 2, sharey=False, tight_layout=True)

    axs[0].scatter(n_RNG_list, np1_RNG_list, marker="o", color=(1,0,0), facecolors='none')
    axs[1].hist(RNG_list2, bins = 20, range = (0,1))

    xlabel = ['Combined RNG n', 'Random number generated by combined RNG']
    ylabel = ['Combined RNG n+1', 'Counts']

    i=0
    for ax in axs:
        ax.set(xlabel=xlabel[i], ylabel=ylabel[i])
        i+=1

    fig.savefig('./plots/RNG-test-results')

    """
    For Question 1b) we will integrate the Gaussian integral using the simplification specified in the PDF. We will use Romberg integration since it is very efficient.
    Unclear what method they expect us to use to fit a line through the 21 obtained integrated points. My guess would be something of the form (alpha/x)**0.5 and then using
    least squares or some bayesian fitting method to get the alpha.
    """
    
    integrationpoints = [2*extmidpointromberg(intfunc, [0,1], 10**2, 4, alpha=2**i) for i in range(-10,11)]
    
    fig2, axs2 = plt.subplots()
    axs2.scatter([2**i for i in range(-10,11)], integrationpoints, s=0.1, label='Extended midpoint Romberg', color = (1,0,0))
    axs2.scatter([2**i for i in range(-10,11)], [(np.pi/(2**i))**0.5 for i in range(-10,11)], s=0.1, label='Exact points', color = (0,1,0))
    axs2.set(xlabel='alpha', ylabel='integral')
    axs2.legend()
    fig2.savefig('./plots/gaussianintegral')

    """
    For Question 1c) Box Muller method can be found in 7.3.4 of the book. Does not seem to be anywhere in the slides.
    """

    """
    For Question 1d) look at the details of lecture 8.
    """
